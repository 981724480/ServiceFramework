{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Serviceframework","tagline":"Java MVC framework, agile, fast, rich domain model, made especially for server side of mobile application (一个敏捷，快速，富领域模型的Java MVC 框架，专为 移动应用后端量身定做)","google":"","body":"#ServiceFramework Wiki\r\n\r\n##  创建一个新的ServiceFramework 项目\r\n\r\n\r\n###ServiceFramework 适合你吗？\r\n\r\nServcieFramework 定位在 **移动互联网后端** 领域。\r\n所以ServcieFramework非常强调开发的高效性，其开发效率可以比肩Rails(不相信？可以体验一下哦)。\r\n\r\n1. 拥有Java界最简单，非常高效，且真正的富Model层\r\n2. Controller层含有便利的函数库，简洁高效的验证器，过滤器\r\n3. 简单但实用的View层，天然支持JSON,XMl格式输出\r\n\r\n框架提供了对mysql,mongodb,redis的支持\r\n\r\n如果你面对的是一个遗留项目或者遗留的数据库，那么ServiceFramework不适合你。我们倾向于在一个全新的项目中使用它。\r\n相信你会为Java也能做到如此的简洁而惊讶，如此高效的开发而窃喜。\r\n\r\n现在让我们了解下 ServiceFramework 吧。\r\n\r\n\r\n\r\n### 搭起来，跑起来\r\n\r\n在终端下赋值黏贴运行该命令:\r\n\r\n```shell\r\ngit clone https://github.com/service_framework/service_framework.git service_framework\r\n```\r\n此时你就获得一个开箱即用的项目。所有的目录和结构都是规范化的。\r\n\r\n####我们先看看目录结构:\r\n\r\n<table>\r\n  <tbody><tr>\r\n\t\t<th>文件/目录</th>\r\n\t\t<th>作用</th>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td>src/</td>\r\n\t\t<td>包含 controllers, models, views。也就是项目源码的存放地。 在之后的教程中，我们会聚焦于这个目录</td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td>config/</td>\r\n\t\t<td>配置文件。整个ServiceFramework只有两个配置文件，分别为application.yml 和logging.yml  更详细的配置介绍参看:<a href=\"#\">配置 ServiceFramework 应用</a></td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td>bin</td>\r\n\t\t<td>存放编译，部署，运行脚本</td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td>sql/</td>\r\n\t\t<td>项目的数据库结构文件。通常是sql文件</td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td>doc/</td>\r\n\t\t<td>项目的文档存放地</td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td>lib</td>\r\n\t\t<td>应用本身，以及包括ServiceFramework依赖的jar包都会存放在这里</td>\r\n\t</tr>\r\n\t\r\n\t<tr>\r\n\t\t<td>logs/</td>\r\n\t\t\r\n\t\t<td>应用程序日志文件</td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td>script/</td>\r\n\t\t<td>一些shell脚本之类的</td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td>client</td>\r\n\t\t<td>你可以写一些客户端，比如使用某种脚本语言，做数据迁移啥的</td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td><span class=\"caps\">README</span>.html</td>\r\n\t\t<td>请对你的项目做一个简要的介绍</td>\r\n\t</tr>\r\n\t\r\n\t<tr>\r\n\t\t<td>test/</td>\r\n\t\t<td>单元测试目录。详细参看:<a href=\"#\">如何测试ServiceFramework应用</a></td>\r\n\t</tr>\r\n\t\r\n</tbody></table>\r\n\r\n##如何运行测试\r\n项目src目录下有一个com.example 示例程序。实现的是一个简单的tag系统。\r\n在test 目录中 test.com.example 有example项目的测试代码。\r\ntest 根目录下的有个文件叫\r\n\r\n```java\r\nDynamicSuiteRunner \r\n```\r\n\r\n你可以在IDE中启动它来运行整个测试集。\r\n\r\n## 如何启动应用。\r\n\r\n你可以在IDE运行\r\n\r\n```java\r\nnet.csdn.bootstrap.Application \r\n```\r\n当然你也可以写一个类继承它。然后运行这个新的类。\r\n\r\n如果你不希望使用IDE.你可以直接进入项目，然后运行:\r\n\r\n```shell\r\n./bin/run.sh start\r\n```\r\n\r\n默认开启9400端口。你可以修改config/application.yml文件来改变端口。\r\n接着可以通过curl 进行测试访问。\r\n\r\n## Model \r\n这个章节，我们会知道 ServiceFramework 模型层 完整的使用。\r\n\r\n首先，建立四张示例表:\r\n\r\n```sql\r\n--标签表\r\nCREATE TABLE `Tag` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `name` varchar(255) DEFAULT NULL,\r\n  `tag_synonym_id` int(11) DEFAULT NULL,\r\n  `weight` int(11) DEFAULT NULL,\r\n  PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB  DEFAULT CHARSET=utf8;\r\n\r\n--标签组。一个标签可以属于多个标签组。一个标签组包含多个标签\r\nCREATE TABLE `TagGroup` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `name` varchar(32) DEFAULT NULL,\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE KEY `id` (`id`)\r\n) ENGINE=InnoDB  DEFAULT CHARSET=utf8;\r\n\r\n--博客和标签的关联表。存有 博客id和标签id\r\nCREATE TABLE `BlogTag` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `tag_id` int(11) DEFAULT NULL,\r\n  `object_id` int(11) DEFAULT NULL,\r\n  `created_at` bigint(20) DEFAULT NULL,\r\n  PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\r\n\r\n--标签近义词组。一个标签只可能属于一个标签近义词\r\nCREATE TABLE `TagSynonym` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `name` varchar(32) DEFAULT NULL,\r\n  PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n```\r\n\r\n\r\n对应的类文件:\r\n\r\n```java\r\n/**\r\n * User: WilliamZhu\r\n * Date: 12-7-23\r\n * Time: 下午4:52\r\n */\r\n@Entity\r\npublic class Tag extends Model {\r\n    @Validate\r\n    private final static Map $name = map(\r\n    presence, map(\"message\", \"{}字段不能为空\"),\r\n    uniqueness, map(\"message\", \"{}字段不能重复\")\r\n    );\r\n\r\n    @OneToMany\r\n    private List<BlogTag> blog_tags = list();\r\n\r\n    @ManyToMany\r\n    private List<TagGroup> tag_groups = list();\r\n}\r\n\r\n\r\n@Entity\r\npublic class BlogTag extends Model {\r\n\r\n    @ManyToOne\r\n    private Tag tag;\r\n}\r\n\r\n@Entity\r\npublic class TagGroup extends Model {\r\n    @ManyToMany\r\n    private List<Tag> tags = list();\r\n}\r\n\r\n@Entity\r\npublic class TagSynonym extends Model {\r\n    @OneToMany\r\n    private List<Tag> tags = list();\r\n}\r\n\r\n\r\n```\r\n\r\n初看模型，你可能会惊讶于代码之少，关联配置之简单。是的，上面就是我们对模型类所有的配置了。你不需要显示声明属性和设置get/set方法，\r\n但是就是这些代码已经可以满足你80%的需求了。哈哈，那让我们\r\n一步一步来看ServiceFrame是如何为你带来这些魔法的。\r\n\r\n我们先介绍一下示例中模型的关系:\r\n\r\n1. TagGroup 和 Tag是多对多关系\r\n2. Tag和BlogTag是一对多关系。\r\n3. TagSynonym 和Tag 是多对一关系\r\n\r\n建立模型类只需要三步:\r\n\r\n1. 继承 Model 基类\r\n2. 添加 Entity 注解\r\n3. 声明集合属性时需要初始化它\r\n\r\nServiceFramework 为你提供了大量便利方法。比如建立map/list\r\n\r\n```java\r\nMap newMap = map();\r\nMap newMap2 = map(\"key1\",\"value1\",\"key2\",\"value2\")\r\nList newList = list();\r\nList newList2 = list(\"value1\",\"value2\",\"value3\");\r\n```\r\n所以集合初始化的时候也变得很简洁，比如示例代码中\r\n\r\n```java\r\n@ManyToMany\r\nprivate List<Tag> tags = list();\r\n```\r\n\r\n### 表和模型之间的映射关系\r\n前面的例子可以看到，我们不需要进行任何表和模型之间的映射配置。这依赖于默认的命名约定。这些规则包括：\r\n\r\n1. 表名和类名相同。比如Tag 在数据库相应的表明也为 Tag\r\n2. 外键名称 = 属性名+\"_id\".\r\n3. 属性名 = 小写 加 下划线的形式。比如示例中的 tag_groups 等。 这和java的传统命名会有些区别。\r\n这主要是为了数据库字段和Model属性名保持一致。如果你使用\"tagGroups\"这种传统的驼峰命名方式,\r\n那么数据库中的字段名就会很丑陋了。遵循现在的方式你会发现这是相当便利的一种方式。\r\n\r\n4. 根据语义区分单复数形式 \r\n5.强烈推荐使用自增id,名称为id,并且为interge类型。这可以省掉很多麻烦\r\n\r\n\r\n### 模型属性\r\n\r\nModel类会自动根据数据库获取信息。所以你无需在Model中定义大量的属性。ServiceFramework会根据数据库表信息\r\n自动生成这些字段。\r\n\r\n假设Tag 含有一个name 属性，可以这样获取它。\r\n\r\n```java\r\nTag tag = Tag.find(17);\r\nString name = tag.attr(\"name\",String.class);\r\n```\r\n赋值的话可以这么做:\r\n\r\n```java\r\ntag.attr(\"name\",\"jack\");\r\n```\r\n\r\n当然你也可以手动定义这些属性，这不会带来任何问题，而且可以获取IDE工具的代码提示。\r\n\r\n### 关联关系\r\n\r\n关联关系可以做两件事情:\r\n\r\n1. 告诉框架模型(表)之间的外键关系\r\n2. 可以方便的级联保存，更新操作\r\n\r\n***WARNING***: 关联关系不应该用来查询。比如 你不应该通过 tag.getBlogTags()获取相关的BlogTag.即使是blogTag.getTag() 这样获取一个对象也不行。在后续的文档中你会看到一个可控性更好，不需要你具有任何ORM知识，规范的查询方式。\r\n\r\nServiceFramework 支持标准的三种种关系。\r\n\r\n* OneToOne\r\n* OneToMany\r\n* ManyToMany\r\n\r\n在ServiceFramework中，所有关系都是双向的。当然，你不必担心这些，你了解这些细节固然好，但是\r\n不了解也没有关系。你只要按照直觉通过四个注解声明模型类的关系即可。\r\n\r\n通常的ORM框架，比如Hibernate,进行关系操作是比较复杂的。比如多对多关系，如果你添加一个关系，你需要\r\n这样做:\r\n\r\n```java\r\ntagGroup.getTags().add(tag);\r\ntag.getTagGroups.add(tagGroup);\r\ntag.save();\r\n```\r\n\r\n另外你可能还需要小心主控端。因为某些情况只有对主控端持久化，才会将关联关系(外键)设置好。\r\n\r\n但是在ServiceFramework 你完全不用担心什么主控端什么的额。对于刚才的示例，ServiceFramework可以这样：\r\n\r\n\r\n```java\r\n tagGroup.associate(\"tags\").add(tag);\r\n```\r\n这个时候tag与tagGroup的关系就已经建立在中间表了。相应的\r\n\r\n```java\r\n tagGroup.associate(\"tags\").remove(tag);\r\n```\r\n\r\n会删除中间表相关的记录。\r\n你也可以用 将tagGroup添加到tag的tagGroups中。效果是一样的。这说明你不需要区分主控端。\r\n\r\n上面我们举的是多对多的例子，实际上也适用于一对多和一对一的关系。\r\n\r\n常见的应用场景是，当你创建一个tag的时候，你需要把它添加到一个已经存在的tagGroup中。\r\n上面的关联关系就可以帮上忙了。\r\n\r\n\r\nassociate方法的参数 “tags“  就是我们定义在TagGroup 中的一个属性。ServiceFramework默认会为\r\n这种集合映射属性添加一个同名的方法，并且返回Association。\r\n\r\n类似于:\r\n\r\n```java\r\npublic Association tags(){throw new AutoGeneration();}\r\n```\r\n\r\nassociate 只是帮你调用这些看不到的方法。\r\n为了获得IDE提示的好处，\r\n你可以把上面那段代码写进你的模型类中。ServiceFramework会去实现里面具体的细节。\r\n\r\n```java\r\n@Entity\r\npublic class TagSynonym extends Model {\r\n    @OneToMany\r\n    private List<Tag> tags = list();\r\n    public Association tags(){throw new AutoGeneration();}\r\n}\r\n```\r\n\r\n现在假设我们要获取一个同义词组所有的d>10的tag，我们可以这么做\r\n\r\n```java\r\nList<Tag> tags = tagSynonym.tags().where(\"id>10\").fetch(); \r\n```\r\n当然，你依然可以写成\r\n\r\n```java\r\nList<Tag> tags = tagSynonym.associate(\"tags\").where(\"id>10\").fetch(); \r\n```\r\n结果是一样的。对于这种只是为了代码提示而创建的方法，我们推荐方法内部 填充 'throw new AutoGeneration()'来标记它会被框架自动实现。虽然，即使它不存在，系统也会创建它。\r\n\r\n经过上面的例子可以看出模型的关联关系可以给我们带来很多便利。这包括从表单获取多个model进行级联保存。\r\n\r\nWARNNING: 集合属性的名称都会有一个同名的方法。这个方法名会被框架保留使用。所以，不要用这个名称来定义对你来说有其他用处的方法。\r\n\r\n\r\n###表单和模型类\r\n\r\n通常表单需要填充模型类。这就和Controller层扯上了关系。为了不使得后面的例子让你困惑，\r\n我们先提一点Controller的预备知识。\r\n\r\nServiceFramework Contoller层获取参数的方式是通过params()函数。\r\n\r\n比如:\r\n\r\n```java\r\n   String name = params(\"name\");\r\n```\r\n\r\n如果不传递key值。那么\r\n\r\n```\r\n Map params = params();\r\n```\r\n\r\n这类似于\r\n\r\n```\r\n Map params = request.getParamsAsMap();\r\n```\r\n\r\n好。Controller我们就讲到这。\r\n\r\n假设我们要创建一个tag\r\n\r\n```\r\nTag tag = Tag.create(params());\r\n```\r\n\r\n每个模型类默认就会有一个接受map对象的create静态方法。该类会利用map自动填充模型类。\r\n\r\n另外，参数支持子对象属性填充。\r\n假设 Tag 有个属性是 tag_wiki的对象属性，你想同时填充它，传参可以这样：\r\n\r\n```\r\nname=java&tag_wiki.name=这真的是一个java标签\r\n```\r\n目前ServiceFramework支持两级填充，这意味着\r\n\r\n```\r\ntag_wiki.tag_info.name \r\n```\r\n这种形式是不被支持的。\r\n\r\n\r\n### 查询接口\r\n\r\nServiceFramework 提供了一套便利，规范，高效，且拥有部分HQL对象特色的查询功能。如果你熟悉Rails框架，那么你便能看到ServiceFramework 借鉴了他那套优秀的 \"Query Interface\"。\r\n\r\n为了高效，规范化的操作数据库, ServiceFramework 提供了众多的查询方法. 每个查询方法允许你传递参数执行特定的查询而不需要你写令人烦躁的sql语句。\r\n\r\n方法列表:\r\n\r\n* where\r\n* select\r\n* group\r\n* order\r\n* limit\r\n* offset\r\n* joins\r\n* from\r\n\r\n以后我们会继续完善。添加更多方法，譬如 lock,having等。\r\n\r\n从这些关键字可以看出，这些方法基本是以Sql关键字为基础的。所有这些方法最终返回的是JPQL对象(ServiceFramework内部组装sql语句的一个类)。\r\n\r\n1.1 根据ID获得对象\r\n\r\n```java\r\nTag.findById(10)\r\n//或者\r\nTag.find(10)\r\n```\r\n1.2 根据多个ID获取\r\n\r\n```java\r\nTag.find(list(1,2,,4,5))\r\n```\r\n1.3 条件查询\r\n\r\n```java\r\nTag.where(\"id=:id\",map(\"id\",7)).fetch();\r\n```\r\nmap 是一个创建Map的一个便利方法。\r\n\r\n你也可以使用一个更复杂的例子:\r\n\r\n```java\r\nTag.where(\"tag_synonym=:tag_synonym\",map(\"tag_synonym\",tag_synonym));\r\n```\r\n还记得之前提到的，对象关联关系的建立，可以方便框架进行一些对象化的操作。在Tag中tag_synonym是一个对象属性，你可以直接在where中使用该属性。\r\n他会转为为类似:\r\n\r\n```java\r\nselect * from Tag where tag_synonym_id=? \r\n```\r\n因为对象关联模型告诉了系统那个是外键。这不会带来任何性能方面的损耗。\r\n\r\n1.4 order\r\n\r\n```java\r\nTag.order(\"id desc\")\r\n```\r\n或者\r\n\r\n```java\r\nTag.order(\"id desc,name asc\")\r\n```\r\n\r\n1.5 joins\r\n\r\njoins 语法也是对象化的，这也得益于我们之前简单的模型关系声明。你所操作的就是相应的模型属性。不管简单属性还是对象属性。\r\n\r\n```java\r\nTag.joins(\"tag_synonym\").fetch();\r\n```\r\n\r\n那么 tag对象的tag_synonym 属性会自动得到填充。这不会有n+1问题。因为一条SQL语句就搞定了\r\n\r\n你也可以join多个属性\r\n\r\n```java\r\nTag.joins(\"tag_synonym left join  tag_groups left join blog_tags\").fetch();\r\n```\r\n当然，对于互联网应用，这么多join毫无疑问会拖垮你的数据库。我们只是举个例子，你不应该这么做。\r\n\r\n1.6 offset,limit\r\n\r\n```java\r\nTag.offset(10).limit(15);\r\n//这相当于\r\nselect * from Tag limit 10,15;\r\n```\r\n\r\n1.7 select \r\n\r\n这通常用于你不想获取所有的字段的场合\r\n\r\n```java\r\n List<Object[]> results =Tag.select(\"name\").fetch();\r\n```\r\n\r\n这通常返回是一个数组。当然，如果你想让它填充进一个模型也是可以的。\r\n\r\n```java\r\n List<Tag> results =Tag.select(\"new Tag(name)\").fetch();\r\n```\r\n需要注意的是，你需要在Tag填充一个相应的构造方法。希望不久就能去掉这个限制。嗯，应该尽力去掉。\r\n\r\n1.8 group\r\n说实话，真不应该提供这个，性能杀手。不过还是提供了….\r\n\r\n```java\r\nTag.where(\"id>10\").group(\"name\").fetch();\r\n```\r\n\r\n###Name_Scope\r\n假设tag需要审核。只有审核通过的才应该被查询出来。如果每次查询的时候都要加这个条件岂不是\r\n太麻烦？我们可以定义一个方法：\r\n\r\n```java\r\n@Entity\r\npublic class Tag extends Model {\r\n    public static JPQL active(){\r\n      return where(\"status=1\");\r\n    }\r\n}\r\n```\r\n\r\n之后你就可以这么用了\r\n\r\n```java\r\nTag.active().where(\"id>10\").join(\"tag_groups\").offset(0).limit(15).fetch();\r\n```\r\n\r\n\r\n### 模型方法\r\n\r\n在ServiceFramework中。一旦你定义了模型类，那么该模型类会自动拥有众多的方法。一些静态方法:\r\n\r\n```java\r\n  Tag.create(map)\r\n\tTag.deleteAll()\r\n\tTag.count()\r\n\tTag.count(String query, Object... params)\r\n\tTag.findAll()\r\n\tTag.findById(Object id)\r\n\tTag.all() \r\n\tTag.delete(String query, Object... params)\r\n\t\r\n\tTag.where(String whereCondition, Object... params)\r\n\tTag.join(String join)\r\n\tTag.order(String order)\r\n\tTag.offset(int offset)\r\n\tTag.limit(int limit)\r\n\tTag.select(String select)\r\n```\r\n\r\n一些实例方法\r\n\r\n```java\r\n    tag.save()\r\n\ttag.valid()\r\n\ttag.update()\r\n\ttag.refresh()\r\n\ttag.delete()\r\n```\r\n\t\r\nServiceFramework还会为你生成很多你看不见的\"模型实例方法\"。你需要特定语法去调用他。这里使用\"m\" 方法。\r\n这主要针对关联关系。\r\n对于类似这种申明:\r\n\r\n```java\r\n@ManyToMany\r\nprivate List<Tag> tags = new ArrayList<Tag>();\r\n```\r\n那么你能获得tags方法。\r\n\r\n```java\r\ntagGroup.m(\"tags\",Tag.create(map(\"name\",\"jack\")));\r\n```\r\n这段代码的含义是，调用tags方法，该方法接受tag实例作为参数。实际上tags方法等价于下面的方法(只是你看不到这个方法，但是能通过\"m”调用他)\r\n\r\n```java\r\n  public TagGroup tags(Tag tag){\r\n       this.tags.add(tag);\r\n       tag.getTag_groups().add(this);\r\n       return this;\r\n  }\r\n```\r\n配置了关联关系的字段都会自动生成一个同名的方法，通过调用他们，会自动将对象之间的关联关系设置好，从而可以直接使用包括级联保存等ORM特性。\r\n\r\n\r\n关于查询，我们强烈建议你使用这一套优美的Query Interface。\r\n\r\n但是复杂的查询依然是有的。这属于%20的不常见需求。\r\n\r\n但是ServiceFramework 依然提供了原生sql的支持。\r\n\r\n这个时候你需要MysqlClient对象。我们提供两种方式引用该类。\r\n\r\n1 通过声明注入的方式(IOC)。适用在Controller层或者Service层使用。\r\n2 直接在Model层可以通过nativeSqlClient()方法获取MysqlClient对象\r\n\r\nMysqlClient 提供的常用接口:\r\n\r\n```java\r\n\r\n//查询\r\npublic List<Map> query(String sql, Object... params) ；\r\npublic Map single_query(String sql, Object... params) ；\r\n\r\n//批量插入或者更新\r\npublic void executeBatch(String sql, BatchSqlCallback callback) \r\n```\r\n\r\n值得注意的是，任何一个Model类都提供了 \r\n\r\n```java\r\nList<Map> findBySql(String sql,Object...params)\r\n```\r\n方法。方便你直接使用Sql查询。\r\n\r\n\r\n###Validator(模型校验器)\r\n\r\nServiceFramework提供了声明式的validator\r\n\r\n```java\r\n@Validate\r\n    private final static Map $name = map(\r\n         presence, map(\"message\", \"{}字段不能为空\"),\r\n         uniqueness, map(\"message\", \"{}字段不能重复\")\r\n    );\r\n\r\n```\r\n\r\n验证器:\r\n\r\n* presence  值不能为null或者空\r\n* uniqueness 值具有唯一性\r\n* numericality 是数字，且可以设置范围\r\n* format  正则\r\n* associated  关联对象验证\r\n* length 长度校验\r\n\r\n你会发现valiator具有以下几个特点:\r\n\r\n1. 想成validator的必要条件是，声明为 private final static 添加 @Validate 注解，并且字段名以$开始 。通常，@Validate注解只是让你知道，这个字段是验证器。否则你可能会对这种以$开头的字段感到疑惑。\r\n2. validator 是一个Map类型的字段\r\n3. $name 中的name 为需要验证的字段名。这里 我们要求Tag中的name不能为空，并且需要具有唯一性。\r\n\r\n你可以显式调用一个模型的valid()方法。你也可以直接调用save()方法。该方法返回boolean.false代表没有通过验证。\r\n验证结果你可以通过直接使用模型的validateResults属性获取。\r\n\r\n```java\r\n if(!tag.save()){\r\n   render(HTTP_400,tag.validateResults);\r\n }\r\n \r\n //或者\r\n \r\n if(tag.valid()){\r\n   tag.save();\r\n }\r\n```\r\n\r\n对于save方法，你也可以跳过验证\r\n\r\n```java\r\ntag.save(false)\r\n```\r\n参数 false 表示不需要验证就进行保存。\r\n\r\n1.1 prensence\r\n\r\n\r\n```java\r\n@Validate\r\nprivate final static Map $name = map(presence, map(\"message\", \"{}字段不能为空\"));\r\n\r\n```\r\n\r\n1.2 uniqueness\r\n\r\n```java\r\n@Validate\r\nprivate final static Map $name = map(uniqueness, map(\"message\", \"\"));\r\n```\r\n\r\n1.3 numericality\r\n\r\n```java\r\n@Validate\r\nprivate final static Map $id = map(numericality, map(\"greater_than\",10,\"message\":\"\"));\r\n```\r\n拥有的选项为:\r\n\r\n* greater_than\r\n* greater_than_or_equal_to\r\n* equal_to\r\n* less_than\r\n* less_than_or_equal_to\r\n* odd\r\n* even\r\n\r\n1.4 length\r\n\r\n```java\r\n@Validate\r\nprivate final static Map $name = map(length, map(\"minimum\",10));\r\n```\r\n拥有的选项:\r\n\r\n* minimum\r\n* maximum\r\n* too_short\r\n* too_long\r\n\r\n###回调\r\n\r\nServiceFramework中，你可以使用标准的JPA回调注解。但是我们依然希望你使用我们替你增强过的回调\r\n\r\n* @BeforeSave\r\n* @AfterSave\r\n* @BeforeUpdate\r\n* @AfterUpdate\r\n* @BeforeDestory\r\n* @AfterLoad\r\n\r\n```java\r\n@Entity\r\npublic class Tag extends Model {\r\n    @AfterUpdate\r\n    public void afterUpdate() {\r\n        findService(RedisClient.class).expire(this.id().toString());\r\n    }\r\n```\r\n需要注意的是，接受注解的方法必须没有参数。\r\nServiceFramework 任何一个模型类都能通过findService 方法获得有用的Service,Util服务。例子中\r\n当更新一个对象的时候，我们就让redis缓存中的对象过期。\r\n\r\n在回调中你依然可调用模型类进行持久化操作。但是需要注意的是 \r\n\r\n1. 不能对本身进行相关的持久化，更新操作。但是可以进行查询动作。\r\n2. 回调函数被包装在一个事务中，执行完后会被立即提交\r\n\r\n\r\n```java\r\n@Entity\r\npublic class Tag extends Model {\r\n    @AfterUpdate\r\n    public void afterUpdate() {\r\n        BlogTag.create(map(\"object_id\",10)).save();\r\n    }\r\n```\r\n\r\n我们期望的是你能定义在模型内。但是如果你想给所有模型方法共用的话，你可以通过类的声明方式。\r\n\r\n```java\r\n@Entity\r\n@EntityListeners(UpdateCallback.class)\r\npublic class Tag extends Model {\r\n```\r\n\r\n相应的类为:\r\n\r\n```java\r\nclass UpdateCallback{\r\n   @AfterUpdate\r\n    public void afterUpdate() {\r\n        findService(RedisClient.class).expire(this.id().toString());\r\n    }\r\n}\r\n```\r\n\r\n\r\n其实，从上面的介绍可以看出，ServiceFramework的Model层是真正富领域模型。关于数据库大部分逻辑操作都应该定义在model层。\r\n当然，Service层依然是需要的。DAO层则被完全摒弃了。通常我们建议，对model调用\r\n可以直接在controller中。而Service则提供其他服务，譬如远程调用，复杂的逻辑判断。当然，\r\n我们完全赞同在Service里调用model。这样对事物也具有较好的控制。\r\n\r\n### 模型类的单元测试\r\n\r\n一个简答的示例如下:\r\n\r\n```java\r\npublic class TagTest extends IocTest {\r\n\r\n\r\n   @Test\r\n    public void associationJPQLTest() {\r\n        setUpTagAndTagSynonymData();\r\n\r\n        TagSynonym tagSynonym = TagSynonym.where(\"name=:name\", map(\"name\", \"java\")).single_fetch();\r\n        List<Tag> tags = tagSynonym.associate(\"tags\").where(\"name=:name\", map(\"name\", \"tag_1\")).limit(1).fetch();\r\n        assertTrue(tags.size() == 1);\r\n\r\n        tearDownTagAndTagSynonymData();\r\n    }\r\n   \r\n}\r\n```\r\n\r\n你可以继承IocTest以获取必要的测试框架支持。当然，如果你希望测试是clean的也可以不继承它。\r\n\r\nServiceFramework  强烈建议：\r\n\r\n***测试要么全部运行，要不都不运行***\r\n\r\n这意味着目前你没法只运行一个测试单元。你必须运行所有测试集。\r\n为此，ServiceFramework在test目录下提供了DynamicSuiteRunner 类。\r\n你可以直接使用支持JUnit的IDE或者通过脚本运行该类即可。该类会自动运行所有配置文件指定package下的所有的测试类。\r\n  \r\n这种方式带来的一个额外好处是，他可以保证你做的任何修改不至于让别人的或者自己写的其他测试奔溃。如果你有机会只运行自己的测试，估计没有多少人会主动去运行所有的测试。在那种情况下，测试就没有意义了。\r\n\r\n## Controller\r\n\r\n下面是一个典型的ServiceFramework Controller.\r\n\r\n```java\r\n\r\npublic class TagController extends ApplicationController {\r\n\r\n    @BeforeFilter\r\n    private final static Map $checkParam = map(only, list(\"save\", \"search\"));\r\n    @BeforeFilter\r\n    private final static Map $findTag = map(only, list(\"addTagToTagGroup\", \"deleteTagToTagGroup\",\"createBlogTag\"));\r\n\r\n\r\n    @AroundFilter\r\n    private final static Map $print_action_execute_time2 = map();\r\n\r\n   \r\n    @At(path = \"/tag_group/create\", types = POST)\r\n    public void createTagGroup() {\r\n        TagGroup tagGroup = TagGroup.create(params());\r\n        if (!tagGroup.save()) {\r\n            render(HTTP_400, tagGroup.validateResults);\r\n        }\r\n        render(OK);\r\n    }\r\n\r\n\r\n    @At(path = \"/tag_group/tag\", types = {PUT, POST})\r\n    public void addTagToTagGroup() {\r\n        TagGroup tagGroup = TagGroup.findById(paramAsInt(\"id\"));\r\n        tagGroup.associate(\"tags\").add(tag);\r\n        render(OK);\r\n    }\r\n\r\n    @At(path = \"/tag_group/tag\", types = {DELETE})\r\n    public void deleteTagToTagGroup() {\r\n        TagGroup tagGroup = TagGroup.findById(paramAsInt(\"id\"));\r\n        tagGroup.associate(\"tags\").remove(tag);\r\n        tagGroup.save();\r\n        render(OK);\r\n    }\r\n\r\n\r\n    @At(path = \"/{tag}/blog_tags\", types = PUT)\r\n    public void createBlogTag() {\r\n        tag.associate(\"blog_tags\").add(BlogTag.create(map(\"object_id\", paramAsInt(\"object_id\"))));\r\n        render(OK);\r\n    }\r\n\r\n\r\n   \r\n    @At(path = \"/doc/{type}/insert\", types = POST)\r\n    public void save() {\r\n\r\n        for (String tagStr : tags) {\r\n            Model model = (Model) invoke_model(param(\"type\"), \"create\", selectMapWithAliasName(paramAsJSON(\"jsonData\"), \"id\", \"object_id\", \"created_at\", \"created_at\"));\r\n            model.m(\"tag\", Tag.create(map(\"name\", tagStr)));\r\n            if (!model.save()) {\r\n                render(HTTP_400, model.validateResults);\r\n            }\r\n        }\r\n        render(OK);\r\n    }\r\n\r\n    @Inject\r\n    private RemoteDataService remoteDataService;\r\n\r\n    \r\n    @At(path = \"/doc/{type}/search\", types = GET)\r\n    public void search() {\r\n\r\n        Set<String> newTags = Tag.synonym(param(\"tags\"));\r\n\r\n\r\n        JPQL query = (JPQL) invoke_model(param(\"type\"), \"where\", \"tag.name in (\" + join(newTags, \",\", \"'\") + \")\");\r\n\r\n        if (!isEmpty(param(\"channelIds\"))) {\r\n            String channelIds = join(param(\"channelIds\").split(\",\"), \",\", \"'\");\r\n            query.where(\"channel_id in (\" + channelIds + \")\");\r\n        }\r\n\r\n        if (!isEmpty(param(\"blockedTagsNames\"))) {\r\n            String blockedTagsNames = join(param(\"blockedTagsNames\").split(\",\"), \",\", \"'\");\r\n            String abc = \"select object_id from \" + param(\"type\") + \" where  tag.name in (\" + blockedTagsNames + \")\";\r\n            query.where(\"object_id not in (\" + abc + \")\");\r\n        }\r\n\r\n        long count = query.count_fetch(\"count(distinct object_id ) as count\");\r\n\r\n        if (!isEmpty(\"orderFields\")) {\r\n            query.order(order());\r\n        }\r\n\r\n        List<Model> models = query.offset(paramAsInt(\"start\", 0)).limit(paramAsInt(\"size\", 15)).fetch();\r\n\r\n        // JSONArray data = remoteDataService.findByIds(param(\"type\"), param(\"fields\"), fetchObjectIds(models));\r\n\r\n        render(map(\"total\", count, \"data\", map()));\r\n    }\r\n\r\n\r\n    private String[] tags;\r\n\r\n    private void checkParam() {\r\n        tags = param(\"tags\", \" \").split(\",\");\r\n        if (tags.length == 0) {\r\n            render(HTTP_400, format(FAIL, \"必须传递标签\"));\r\n        }\r\n    }\r\n\r\n    private Tag tag;\r\n\r\n    private void findTag() {\r\n        tag = Tag.where(\"name=:name\", map(\"name\", param(\"tag\"))).single_fetch();\r\n        if (tag == null) {\r\n            render(HTTP_400, format(FAIL, \"必须传递tag参数\"));\r\n        }\r\n    }\r\n\r\n    private String fetchObjectIds(List<Model> models) {\r\n        List<Integer> ids = new ArrayList<Integer>(models.size());\r\n        for (Model model : models) {\r\n            ids.add(model.attr(\"object_id\", Integer.class));\r\n        }\r\n        return join(ids, \",\");\r\n    }\r\n\r\n    private String order() {\r\n        String[] orderFields = param(\"orderFields\").split(\",\");\r\n        String[] orderFieldsDescAsc = param(\"orderFieldsDescAsc\", \"\").split(\",\");\r\n        List<String> temp = new ArrayList<String>();\r\n        int i = 0;\r\n        for (String str : orderFields) {\r\n            if (orderFieldsDescAsc.length < i) {\r\n                temp.add(str + \" \" + orderFieldsDescAsc[i]);\r\n            } else {\r\n                temp.add(str + \" \" + \"desc\");\r\n            }\r\n\r\n        }\r\n        return join(temp, \",\");\r\n    }\r\n\r\n    private Object invoke_model(String type, String method, Object... params) {\r\n        return ReflectHelper.method(const_model_get(type), method, params);\r\n    }\r\n    \r\n     private void print_action_execute_time2(RestController.WowAroundFilter wowAroundFilter) {\r\n        long time1 = System.currentTimeMillis();\r\n\r\n        wowAroundFilter.invoke();\r\n        logger.info(\"execute time2:[\" + (System.currentTimeMillis() - time1) + \"]\");\r\n\r\n    }\r\n\r\n\r\n}\r\n```\r\n这个类有点长，主要是为了较为全面的展示Controller的使用，希望不要引起你的不适。\r\n我们再来分析ServiceFramework的controller有什么特点。\r\n\r\n1. 成为Controller的必要条件是继承 ApplicationController\r\n2. 类似Model验证器，你可以以相似的方式添加过滤器\r\n3. 通过At配置路径以及接受的Http 请求方式\r\n4. 所有其他的Service或者Util推荐采用使用IOC容器管理。譬如例子里的RemoteDataService\r\n5. filter只是一个简单的私有方法。如果申明在ApplicationController。那么对所有controller有效\r\n\r\n\r\n###过滤器\r\n\r\nServiceFramework 目前支持两种过滤器\r\n\r\n1. BeforeFilter 前置过滤器\r\n2. AroundFilter 环绕过滤器\r\n\r\n如同示例，过滤的器声明非常简单\r\n\r\n* private,final static 三个修饰符\r\n* 过滤器 @BeforeFilter 或者 @AroundFilter 注解声明\r\n\r\n\r\n\r\n```java\r\n  @BeforeFilter\r\n    private final static Map $checkParam = map(only, list(\"save\", \"search\"));\r\n```\r\n\r\nfilter是声明在一个map属性上的。map 接受两个属性，only,except。如果没有这两个属性，那么表示过滤当前Controller中所有Action。\r\n属性依然以$开头，后面的属性名其实是一个方法的名称。比如你会发现在上面的controller中确实包含一个checkParam 方法。\r\n\r\n例子的含义是，只有save,search两个Action方法在调用前会先调用checkParam。\r\n\r\nController是多线程安全的。这意味着，你可以安全的使用实例变量。示例中\"addTagToTagGroup\", \"deleteTagFromoTagGroup\",\"createBlogTag\" 三个Action在调用前都需要事先获得tag对象。你可以使用findTag过滤器先填充 tag实例变量。如果用户没有传递tag名，就可以在过滤器中直接告诉用户参数问题。\r\n\r\n需要注意的一点是，BeforeFilter 比 AroundFilter 运行的更早。Filter 也可以调用render 方法，进行结果输出。\r\n\r\n###路径配置\r\n\r\n路径配置使用的也是注解配置。\r\n\r\n```java\r\n@At(path = \"/tag_group/tag\", types = {PUT, POST})\r\n```\r\n\r\n@At注解接受两个参数，path 和 types\r\n\r\npath 代表请求路径。 types则是表示接受的请求方法的,默认是GET.\r\n\r\npath 支持占位符，比如:\r\n\r\n```java\r\n@At(path = \"/{tag}/blog_tags\", types = PUT)\r\n```\r\ntag这个值会被自动填充到请求对象中。你可以通过 param(\"tag\")获取。\r\n\r\n\r\n#### request 参数获取\r\n\r\n在ServiceFramework 中 提供了一个非常便利的获取request参数的方式。不管是form表单,get请求，还是url中的数据，都可以统一通过param() 方法获取。\r\n\r\n```java\r\nint id = paramAsInt(\"id\");\r\n//或者\r\nString id = param(\"id\");\r\n```\r\n\r\n比如这就可以获取 id 参数，并且将其转换为int类型。\r\n如果你确认传递过来的是json或者xml格式，你可以调用下面的方式\r\n\r\n```java\r\nJSON obj = paramAsJSON();\r\n//或者\r\nJSON obj = paramsAsXML();\r\n```\r\n其中,xml文本的数据会自动转化json格式,便与操作。\r\n\r\nServiceFramework 尽量让事情简单而方便。\r\n\r\n方法列表:\r\n\r\n```java\r\nparams()\r\nparam(key)\r\nparam(key,defaultValue)\r\nparamAsInt(key)\r\nparamAsLong(key)\r\nparamAsFloat(key)\r\n//还有更多….\r\n```\r\n\r\n\r\n#### 渲染输出\r\n\r\n所有渲染输出统一使用render 方法。\r\n\r\n普通文本输出\r\n\r\n```java\r\nrender(\"hello word\");\r\n```\r\n\r\n如果传入的是对象，会自动呗转化为json格式\r\n\r\n```java\r\nrender(tag);\r\n```\r\n\r\n你可以手动指定输出格式\r\n\r\n```java\r\nrender(tag,ViewType.xml);\r\n```\r\n\r\n你还可以指定输出的http状态码\r\n\r\n```java\r\nrender(HTTP_200,tag,ViewType.xml);\r\n```\r\n\r\nrender 方法也可以在过滤器中使用。一旦调用render方法后，就会自动跳过action调用。\r\n\r\n```java\r\n@At(path = \"/tag_group/create\", types = POST)\r\n    public void createTagGroup() {\r\n        TagGroup tagGroup = TagGroup.create(params());\r\n        if (!tagGroup.save()) {\r\n            render(HTTP_400, tagGroup.validateResults);\r\n        }\r\n        render(OK);\r\n    }\r\n```\r\n\r\n在上面的示例代码中，你无需render之后再调用return 语句。\r\n\r\n\r\n###ServiceFramework\r\n\r\n```java\r\n@Inject\r\nprivate RemoteDataService remoteDataService;\r\n```\r\n\r\n之后你就可以在Action中直接使用remoteDataService了。\r\n\r\n#### Controller提供的便利的方法集\r\n\r\n在controller中，你天然会获取大量有用的工具方法。比如 isEmpty，字符串join。比如\r\n\r\n```java\r\nJPQL query = (JPQL) invoke_model(param(\"type\"), \"where\", \"tag.name in (\" + join(newTags, \",\", \"'\") + \")\");\r\n```\r\n\r\n## 配置文件\r\n\r\nServiceFramework 所有的配置文件位于config目录下。其实只有两个配置文件，一个application.yml,\r\n一个logging.yml.分别配置应用和日志。\r\n\r\n一个完整的application.yml\r\n\r\n```yaml\r\n#mode\r\nmode:\r\n  development\r\n#mode=production\r\n\r\n###############datasource config##################\r\n#mysql,mongodb,redis等数据源配置方式\r\ndevelopment:\r\n    datasources:\r\n        mysql:\r\n           host: 127.0.0.1\r\n           port: 3306\r\n           database: tag_engine\r\n           username: tag\r\n           password: tag\r\n        mongodb:\r\n           host: 127.0.0.1\r\n           port: 27017\r\n           database: tag_engine\r\n        redis:\r\n            host: 127.0.0.1\r\n            port: 6379\r\n\r\nproduction:\r\n    datasources:\r\n        mysql:\r\n           host: 127.0.0.1\r\n           port: 3306\r\n           database: tag_engine\r\n           username: tag\r\n           password: tag\r\n        mongodb:\r\n           host: 127.0.0.1\r\n           port: 27017\r\n           database: tag_engine\r\n        redis:\r\n            host: 127.0.0.1\r\n            port: 6379\r\n\r\norm:\r\n    show_sql: true\r\n    pool_min_size: 5\r\n    pool_max_size: 10\r\n    timeout: 300\r\n    max_statements: 50\r\n    idle_test_period: 3000\r\n###############application config##################\r\napplication:\r\n    controller: com.example.controller\r\n    model:      com.example.model\r\n    service:    com.example.service\r\n    util:       com.example.util\r\n    test:       test.com.example\r\n\r\n\r\n###############http config##################\r\nhttp:\r\n    port: 9400\r\n\r\n\r\n\r\n###############validator config##################\r\n#如果需要添加验证器，只要配置好类全名即可\r\n#替换验证器实现，则替换相应的类名即可\r\n#warning: 自定义验证器实现需要线程安全\r\n\r\nvalidator:\r\n   format:        net.csdn.validate.impl.Format\r\n   numericality:  net.csdn.validate.impl.Numericality\r\n   presence:      net.csdn.validate.impl.Presence\r\n   uniqueness:    net.csdn.validate.impl.Uniqueness\r\n   length:        net.csdn.validate.impl.Length\r\n   associated:    net.csdn.validate.impl.Associated\r\n\r\n################ 数据库类型映射 ####################\r\ntype_mapping:  net.csdn.jpa.type.impl.MysqlType\r\n\r\n```\r\n\r\n对于数据库等的配置是区分开发或者生产环境的\r\n\r\n里面有个join 方法。表示将newTags集合的元素以\",\"进行分割，并且用\"'\"wrap起来组成一个字符串。"}